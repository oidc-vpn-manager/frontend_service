"""
Unit tests for the server bundle API endpoint logic.
"""

import io
import json
import tarfile
import uuid
import pytest
from unittest.mock import patch, MagicMock, call
from flask import Flask
from app import create_app
from app.extensions import db
from app.models.presharedkey import PreSharedKey
from app.utils.signing_client import SigningServiceError
from app.utils.server_template_manager import ServerTemplateManager


class TestServerBundleUnit:
    """Unit tests for server bundle functionality."""

    @pytest.fixture
    def app(self):
        """Create a test Flask app with database."""
        import os
        # Set required environment variables for testing
        os.environ['FLASK_SECRET_KEY'] = 'test-secret-key-for-testing-only'
        os.environ['FERNET_ENCRYPTION_KEY'] = 'test-encryption-key-for-testing-only-32-chars-long'
        os.environ['TESTING'] = 'True'
        
        app = create_app('testing')
        app.config.update({
            'TESTING': True,
            'SQLALCHEMY_DATABASE_URI': 'sqlite:///:memory:',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key-for-testing-only',
            'ENCRYPTION_KEY': 'test-encryption-key-for-testing-only-32-chars',
            'ROOT_CA_CERTIFICATE': 'test-root-ca',
            'INTERMEDIATE_CA_CERTIFICATE': 'test-intermediate-ca',
            'OPENVPN_TLS_CRYPT_KEY': '-----BEGIN OpenVPN Static key V1-----\ntest-key\n-----END OpenVPN Static key V1-----',
            'TEMPLATE_COLLECTION': []
        })
        
        with app.app_context():
            db.create_all()
            # Create a test PSK with a fixed UUID key for consistent testing
            test_key = 'f47ac10b-58cc-4372-a567-0e02b2c3d479'  # Fixed UUID for testing
            test_psk = PreSharedKey(
                description='test-server',
                key=test_key,
                is_enabled=True
            )
            db.session.add(test_psk)
            db.session.commit()
            
            yield app

    @pytest.fixture
    def client(self, app):
        """Create a test client."""
        return app.test_client()

    def test_server_bundle_tar_file_structure(self, client):
        """Test that the tar file contains the correct structure."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
             patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
             patch('app.routes.api.v1.create_server_template_manager') as mock_create_mgr, \
             patch('app.routes.api.v1.find_best_template_match') as mock_template, \
             patch('app.routes.api.v1.render_config_template') as mock_render, \
             patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
            
            # Setup mocks
            mock_key = MagicMock()
            mock_key.private_bytes.return_value = b'server-private-key'
            mock_csr = MagicMock()
            mock_csr.public_bytes.return_value = b'server-csr'
            mock_gen_key.return_value = (mock_key, mock_csr)
            mock_sign_cert.return_value = 'server-certificate'
            mock_tls_process.return_value = (1, 'tls-crypt-key-content')
            
            # Mock server template manager that returns None (fallback to regular templates)
            mock_manager = MagicMock()
            mock_create_mgr.return_value = mock_manager
            mock_manager.find_template_for_config.return_value = None
            
            # Mock regular template fallback
            mock_template.return_value = ('test.ovpn', 'template-content')
            mock_render.side_effect = ['udp-config-content', 'tcp-config-content']

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Verify response
            assert response.status_code == 200
            assert response.mimetype == 'application/gzip'
            assert 'openvpn-server-test-server.tar.gz' in response.headers['Content-Disposition']

            # Extract and verify tar contents with fallback filenames
            tar_buffer = io.BytesIO(response.data)
            with tarfile.open(fileobj=tar_buffer, mode='r:gz') as tar:
                file_names = tar.getnames()
                expected_files = [
                    'ca-chain.crt',
                    'server.crt', 
                    'server.key',
                    'tls-crypt.key',
                    'server-udp-1194.ovpn',  # Default fallback filename
                    'server-tcp-443.ovpn'    # Default fallback filename
                ]
                
                for expected_file in expected_files:
                    assert expected_file in file_names

    def test_server_bundle_certificate_generation(self, client):
        """Test certificate generation parameters."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
             patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
             patch('app.routes.api.v1.find_best_template_match') as mock_template, \
             patch('app.routes.api.v1.render_config_template') as mock_render, \
             patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
            
            # Setup mocks
            mock_key = MagicMock()
            mock_key.private_bytes.return_value = b'server-private-key'
            mock_csr = MagicMock()
            mock_csr.public_bytes.return_value = b'server-csr'
            mock_gen_key.return_value = (mock_key, mock_csr)
            mock_sign_cert.return_value = 'server-certificate'
            mock_template.return_value = ('test.ovpn', 'template-content')
            mock_render.return_value = 'config-content'
            mock_tls_process.return_value = (1, 'tls-crypt-key-content')

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Verify certificate generation called with correct common name
            mock_gen_key.assert_called_once_with(common_name='server-test-server')
            
            # Verify CSR was signed with server certificate type and client IP
            mock_sign_cert.assert_called_once_with('server-csr', certificate_type='server', client_ip='127.0.0.1')

    def test_server_bundle_template_rendering(self, client):
        """Test template rendering with correct contexts (fallback to regular templates)."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
             patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
             patch('app.routes.api.v1.create_server_template_manager') as mock_create_mgr, \
             patch('app.routes.api.v1.find_best_template_match') as mock_template, \
             patch('app.routes.api.v1.render_config_template') as mock_render, \
             patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
            
            # Setup mocks
            mock_key = MagicMock()
            mock_key.private_bytes.return_value = b'server-private-key'
            mock_csr = MagicMock()
            mock_csr.public_bytes.return_value = b'server-csr'
            mock_gen_key.return_value = (mock_key, mock_csr)
            mock_sign_cert.return_value = 'server-certificate'
            mock_tls_process.return_value = (1, 'tls-crypt-key')
            
            # Mock server template manager that returns None (fallback to regular templates)
            mock_manager = MagicMock()
            mock_create_mgr.return_value = mock_manager
            mock_manager.find_template_for_config.return_value = None
            
            # Mock regular template fallback
            mock_template.return_value = ('test.ovpn', 'template-content')
            mock_render.side_effect = ['udp-config', 'tcp-config']

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Verify server template manager tried to find templates
            assert mock_manager.find_template_for_config.call_count == 2
            mock_manager.find_template_for_config.assert_any_call('udp', '1194')
            mock_manager.find_template_for_config.assert_any_call('tcp', '443')

            # Verify fallback to regular template matching (called twice, once for UDP, once for TCP)
            assert mock_template.call_count == 2
            for call_args in mock_template.call_args_list:
                args, kwargs = call_args
                assert args[1] == []  # Empty groups for server template

            # Verify render_config_template called twice (UDP and TCP)
            assert mock_render.call_count == 2
            
            # Check UDP context
            udp_call = mock_render.call_args_list[0]
            udp_context = udp_call[1]  # kwargs
            assert udp_context['proto'] == 'udp'
            assert udp_context['port'] == '1194'
            assert udp_context['common_name'] == 'server-test-server'
            assert udp_context['description'] == 'test-server'
            assert udp_context['ca_cert_pem'] == 'test-intermediate-ca\ntest-root-ca'
            assert udp_context['device_cert_pem'] == 'server-certificate'
            assert udp_context['device_key_pem'] == 'server-private-key'
            assert udp_context['tlscrypt_key'] == 'tls-crypt-key'
            assert udp_context['tlscrypt_version'] == 1
            assert udp_context['userinfo']['name'] == 'OpenVPN Server test-server'
            assert udp_context['userinfo']['email'] == 'server-test-server@local'
            
            # Check TCP context
            tcp_call = mock_render.call_args_list[1]
            tcp_context = tcp_call[1]  # kwargs
            assert tcp_context['proto'] == 'tcp'
            assert tcp_context['port'] == '443'

    def test_server_bundle_ca_chain_handling(self, client):
        """Test CA certificate chain handling."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
             patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
             patch('app.routes.api.v1.create_server_template_manager') as mock_create_mgr, \
             patch('app.routes.api.v1.find_best_template_match') as mock_template, \
             patch('app.routes.api.v1.render_config_template') as mock_render, \
             patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
            
            # Setup mocks
            mock_key = MagicMock()
            mock_key.private_bytes.return_value = b'server-private-key'
            mock_csr = MagicMock()
            mock_csr.public_bytes.return_value = b'server-csr'
            mock_gen_key.return_value = (mock_key, mock_csr)
            mock_sign_cert.return_value = 'server-certificate'
            mock_tls_process.return_value = (1, 'tls-crypt-key')
            
            # Mock server template manager that returns None (fallback to regular templates)
            mock_manager = MagicMock()
            mock_create_mgr.return_value = mock_manager
            mock_manager.find_template_for_config.return_value = None
            
            # Mock regular template fallback
            mock_template.return_value = ('test.ovpn', 'template-content')
            mock_render.return_value = 'config-content'

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Extract tar and check CA chain
            tar_buffer = io.BytesIO(response.data)
            with tarfile.open(fileobj=tar_buffer, mode='r:gz') as tar:
                ca_chain_content = tar.extractfile('ca-chain.crt').read().decode('utf-8')
                assert 'test-intermediate-ca' in ca_chain_content
                assert 'test-root-ca' in ca_chain_content

    def test_server_bundle_empty_ca_certificates(self, app, client):
        """Test handling of empty CA certificates."""
        with app.app_context():
            app.config['ROOT_CA_CERTIFICATE'] = ''
            app.config['INTERMEDIATE_CA_CERTIFICATE'] = ''
            
            with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
                 patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
                 patch('app.routes.api.v1.create_server_template_manager') as mock_create_mgr, \
                 patch('app.routes.api.v1.find_best_template_match') as mock_template, \
                 patch('app.routes.api.v1.render_config_template') as mock_render, \
                 patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
                
                # Setup mocks
                mock_key = MagicMock()
                mock_key.private_bytes.return_value = b'server-private-key'
                mock_csr = MagicMock()
                mock_csr.public_bytes.return_value = b'server-csr'
                mock_gen_key.return_value = (mock_key, mock_csr)
                mock_sign_cert.return_value = 'server-certificate'
                mock_tls_process.return_value = (1, 'tls-crypt-key')
                
                # Mock server template manager that returns None (fallback to regular templates)
                mock_manager = MagicMock()
                mock_create_mgr.return_value = mock_manager
                mock_manager.find_template_for_config.return_value = None
                
                # Mock regular template fallback
                mock_template.return_value = ('test.ovpn', 'template-content')
                mock_render.return_value = 'config-content'

                # Make request
                response = client.post('/api/v1/server/bundle',
                                     headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                     json={'description': 'test-server'})

                # Should succeed with empty CA chain
                assert response.status_code == 200
                
                # Extract tar and check CA chain is empty
                tar_buffer = io.BytesIO(response.data)
                with tarfile.open(fileobj=tar_buffer, mode='r:gz') as tar:
                    ca_chain_content = tar.extractfile('ca-chain.crt').read().decode('utf-8')
                    assert ca_chain_content == ''

    def test_server_bundle_no_tls_crypt_key(self, app, client):
        """Test handling when no TLS-Crypt key is configured."""
        with app.app_context():
            app.config['OPENVPN_TLS_CRYPT_KEY'] = None
            
            with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
                 patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
                 patch('app.routes.api.v1.create_server_template_manager') as mock_create_mgr, \
                 patch('app.routes.api.v1.find_best_template_match') as mock_template, \
                 patch('app.routes.api.v1.render_config_template') as mock_render, \
                 patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
                
                # Setup mocks
                mock_key = MagicMock()
                mock_key.private_bytes.return_value = b'server-private-key'
                mock_csr = MagicMock()
                mock_csr.public_bytes.return_value = b'server-csr'
                mock_gen_key.return_value = (mock_key, mock_csr)
                mock_sign_cert.return_value = 'server-certificate'
                mock_tls_process.return_value = (None, None)  # No TLS key
                
                # Mock server template manager that returns None (fallback to regular templates)
                mock_manager = MagicMock()
                mock_create_mgr.return_value = mock_manager
                mock_manager.find_template_for_config.return_value = None
                
                # Mock regular template fallback
                mock_template.return_value = ('test.ovpn', 'template-content')
                mock_render.return_value = 'config-content'

                # Make request
                response = client.post('/api/v1/server/bundle',
                                     headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                     json={'description': 'test-server'})

                # Should succeed with empty TLS-Crypt key
                assert response.status_code == 200
                
                # Extract tar and check TLS-Crypt key is empty
                tar_buffer = io.BytesIO(response.data)
                with tarfile.open(fileobj=tar_buffer, mode='r:gz') as tar:
                    tls_key_content = tar.extractfile('tls-crypt.key').read().decode('utf-8')
                    assert tls_key_content == ''

    def test_server_bundle_signing_service_error(self, client):
        """Test handling of signing service errors."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
             patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert:
            
            # Setup mocks
            mock_key = MagicMock()
            mock_csr = MagicMock()
            mock_csr.public_bytes.return_value = b'server-csr'
            mock_gen_key.return_value = (mock_key, mock_csr)
            mock_sign_cert.side_effect = SigningServiceError("Service unavailable")

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Verify error response
            assert response.status_code == 503
            data = json.loads(response.data)
            assert data['error'] == 'Signing service unavailable'

    def test_server_bundle_generic_exception(self, client):
        """Test handling of generic exceptions."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key:
            # Setup mock to raise generic exception
            mock_gen_key.side_effect = ValueError("Generic error")

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Verify error response
            assert response.status_code == 500
            data = json.loads(response.data)
            assert data['error'] == 'An internal error occurred'

    def test_server_bundle_file_sizes_in_tar(self, client):
        """Test that tar file entries have correct sizes."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
             patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
             patch('app.routes.api.v1.create_server_template_manager') as mock_create_mgr, \
             patch('app.routes.api.v1.find_best_template_match') as mock_template, \
             patch('app.routes.api.v1.render_config_template') as mock_render, \
             patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
            
            # Setup mocks with specific content
            mock_key = MagicMock()
            mock_key.private_bytes.return_value = b'server-private-key-content'
            mock_csr = MagicMock()
            mock_csr.public_bytes.return_value = b'server-csr-content'
            mock_gen_key.return_value = (mock_key, mock_csr)
            mock_sign_cert.return_value = 'server-certificate-content'
            mock_tls_process.return_value = (1, 'tls-crypt-key-content')
            
            # Mock server template manager that returns None (fallback to regular templates)
            mock_manager = MagicMock()
            mock_create_mgr.return_value = mock_manager
            mock_manager.find_template_for_config.return_value = None
            
            # Mock regular template fallback
            mock_template.return_value = ('test.ovpn', 'template-content')
            mock_render.side_effect = ['udp-config-content', 'tcp-config-content']

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Extract tar and verify sizes
            tar_buffer = io.BytesIO(response.data)
            with tarfile.open(fileobj=tar_buffer, mode='r:gz') as tar:
                # Check each file size matches content
                for member in tar.getmembers():
                    if member.name == 'server.crt':
                        assert member.size == len('server-certificate-content')
                    elif member.name == 'server.key':
                        assert member.size == len('server-private-key-content')
                    elif member.name == 'server-udp-1194.ovpn':
                        assert member.size == len('udp-config-content')
                    elif member.name == 'server-tcp-443.ovpn':
                        assert member.size == len('tcp-config-content')
                    elif member.name == 'tls-crypt.key':
                        assert member.size == len('tls-crypt-key-content')
                    elif member.name == 'ca-chain.crt':
                        expected_ca_chain = 'test-intermediate-ca\ntest-root-ca'
                        assert member.size == len(expected_ca_chain)

    def test_server_bundle_with_server_templates(self, client):
        """Test server bundle generation using server template manager."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
             patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
             patch('app.routes.api.v1.create_server_template_manager') as mock_create_mgr, \
             patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
            
            # Setup mocks
            mock_key = MagicMock()
            mock_key.private_bytes.return_value = b'server-private-key'
            mock_csr = MagicMock()
            mock_csr.public_bytes.return_value = b'server-csr'
            mock_gen_key.return_value = (mock_key, mock_csr)
            mock_sign_cert.return_value = 'server-certificate'
            mock_tls_process.return_value = (1, 'tls-crypt-key')
            
            # Mock server template manager
            mock_manager = MagicMock()
            mock_create_mgr.return_value = mock_manager
            
            # Mock UDP template
            udp_template = {
                'filename': 'udp-template.ovpn',
                'protocol': 'udp',
                'port': 1194,
                'output_filename': 'custom-udp-{{ template_port }}.ovpn'
            }
            
            # Mock TCP template
            tcp_template = {
                'filename': 'tcp-template.ovpn', 
                'protocol': 'tcp',
                'port': 443,
                'output_filename': 'custom-tcp-{{ template_port }}.ovpn'
            }
            
            mock_manager.find_template_for_config.side_effect = [udp_template, tcp_template]
            mock_manager.render_server_config.side_effect = ['udp-config-content', 'tcp-config-content']
            mock_manager.get_output_filename.side_effect = ['custom-udp-1194.ovpn', 'custom-tcp-443.ovpn']

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Verify response
            assert response.status_code == 200
            
            # Extract and verify tar contents with custom filenames
            tar_buffer = io.BytesIO(response.data)
            with tarfile.open(fileobj=tar_buffer, mode='r:gz') as tar:
                file_names = tar.getnames()
                
                # Check that custom filenames are used
                assert 'custom-udp-1194.ovpn' in file_names
                assert 'custom-tcp-443.ovpn' in file_names
                
                # Verify server template manager was called correctly
                assert mock_manager.find_template_for_config.call_count == 2
                mock_manager.find_template_for_config.assert_any_call('udp', '1194')
                mock_manager.find_template_for_config.assert_any_call('tcp', '443')
                
                assert mock_manager.render_server_config.call_count == 2
                assert mock_manager.get_output_filename.call_count == 2

    def test_server_bundle_fallback_to_regular_templates(self, client):
        """Test fallback to regular templates when server templates not found."""
        with patch('app.routes.api.v1.generate_key_and_csr') as mock_gen_key, \
             patch('app.routes.api.v1.request_signed_certificate') as mock_sign_cert, \
             patch('app.routes.api.v1.create_server_template_manager') as mock_create_mgr, \
             patch('app.routes.api.v1.find_best_template_match') as mock_template, \
             patch('app.routes.api.v1.render_config_template') as mock_render, \
             patch('app.routes.api.v1.process_tls_crypt_key') as mock_tls_process:
            
            # Setup mocks
            mock_key = MagicMock()
            mock_key.private_bytes.return_value = b'server-private-key'
            mock_csr = MagicMock()
            mock_csr.public_bytes.return_value = b'server-csr'
            mock_gen_key.return_value = (mock_key, mock_csr)
            mock_sign_cert.return_value = 'server-certificate'
            mock_tls_process.return_value = (1, 'tls-crypt-key')
            
            # Mock server template manager that returns None (no templates found)
            mock_manager = MagicMock()
            mock_create_mgr.return_value = mock_manager
            mock_manager.find_template_for_config.return_value = None
            
            # Mock regular template fallback
            mock_template.return_value = ('fallback.ovpn', 'fallback-template-content')
            mock_render.side_effect = ['udp-fallback-config', 'tcp-fallback-config']

            # Make request
            response = client.post('/api/v1/server/bundle',
                                 headers={'Authorization': 'Bearer f47ac10b-58cc-4372-a567-0e02b2c3d479'},
                                 json={'description': 'test-server'})

            # Verify response
            assert response.status_code == 200
            
            # Extract and verify tar contents use default filenames
            tar_buffer = io.BytesIO(response.data)
            with tarfile.open(fileobj=tar_buffer, mode='r:gz') as tar:
                file_names = tar.getnames()
                
                # Check that default filenames are used
                assert 'server-udp-1194.ovpn' in file_names
                assert 'server-tcp-443.ovpn' in file_names
                
                # Verify fallback to regular templates was used
                assert mock_template.call_count == 2
                assert mock_render.call_count == 2